package cli

import (
	"fmt"

	"github.com/alecthomas/kong"

	actx "go.hackfix.me/disco/app/context"
	aerrors "go.hackfix.me/disco/app/errors"
	"go.hackfix.me/disco/core"
	"go.hackfix.me/disco/crypto"
	"go.hackfix.me/disco/db/models"
)

// The Remote command manages remote Disco nodes.
type Remote struct {
	Add struct {
		Name    string `arg:"" help:"The unique name of the remote."`
		Address string `arg:"" help:"The remote address in 'host[:port]' format, where 'host' can be a DNS hostname or an IP address."`
		Token   string `arg:"" help:"The invitation token used for authentication, generated by the remote node."`
	} `kong:"cmd,help='Add a new remote node.'"`
	Ls struct {
	} `kong:"cmd,help='List remote nodes.'"`
	Rm struct {
		Name string `arg:"" help:"The unique name of the remote."`
	} `kong:"cmd,help='Delete a remote node.'"`
	Update struct {
		Name    string `arg:"" help:"The unique name of the remote."`
		Address string `arg:"" help:"The remote address in 'host[:port]' format, where 'host' can be a DNS hostname or an IP address."`
	} `kong:"cmd,help='Update a remote node.'"`
}

// Run the remote command.
func (r *Remote) Run(kctx *kong.Context, appCtx *actx.Context) error {
	dbCtx := appCtx.DB.NewContext()

	switch kctx.Args[1] {
	case "add":
		response, err := core.RemoteAuth(appCtx.Ctx, r.Add.Address, r.Add.Token)
		if err != nil {
			return err
		}

		tlsClientCertEnc, err := crypto.EncryptSymInMemory(response.TLSClientCert, appCtx.User.PrivateKey)
		if err != nil {
			return fmt.Errorf("failed encrypting TLS client certificate: %w", err)
		}
		tlsClientKeyEnc, err := crypto.EncryptSymInMemory(response.TLSClientKey, appCtx.User.PrivateKey)
		if err != nil {
			return fmt.Errorf("failed encrypting TLS client private key: %w", err)
		}

		remote := models.NewRemote(
			r.Add.Name, r.Add.Address, response.TLSCACert, response.TLSServerSAN,
			tlsClientCertEnc, tlsClientKeyEnc,
		)
		if err := remote.Save(dbCtx, appCtx.DB, false); err != nil {
			return err
		}
	case "ls":
		remotes, err := models.Remotes(dbCtx, appCtx.DB, nil)
		if err != nil {
			return aerrors.NewRuntimeError("failed listing remotes", err, "")
		}

		data := make([][]string, len(remotes))
		for i, r := range remotes {
			data[i] = []string{r.Name, r.Address}
		}

		if len(data) > 0 {
			header := []string{"Name", "Address"}
			newTable(header, data, appCtx.Stdout).Render()
		}
	case "rm":
	case "update":
	}

	return nil
}
