package core

import (
	"context"
	"crypto/ed25519"
	"encoding/json"
	"fmt"
	"slices"

	"github.com/mr-tron/base58"

	"go.hackfix.me/disco/crypto"
	"go.hackfix.me/disco/web/client"
	"go.hackfix.me/disco/web/server/types"
)

// RemoteAuth attempts to connect to a remote Disco server, and authenticate
// with the given invitation token. The token is a concatentation of 32 bytes of
// random data and the public X25519 key of the remote node, as generated by the
// `invite user` command, and transmitted out-of-band by the user to the client
// node. If the authentication is successful, it returns the TLS server (CA)
// certificate, the unencrypted TLS client certificate, and the unencrypted TLS
// client private key.
// See the inline comments for details about the process.
func RemoteAuth(ctx context.Context, address, token string) (
	*types.RemoteJoinResponsePayload, error,
) {
	// 1. Extract the random token data, and the remote X25519 public key from
	// the composite token.
	tokenData, remotePubKeyData, err := decodeToken(token)
	if err != nil {
		return nil, err
	}

	// 2. Generate an ephemeral X25519 key pair, and perform ECDH key exchange
	// in order to generate a shared secret key.
	sharedKey, pubKeyData, err := crypto.ECDHExchange(remotePubKeyData, nil)
	if err != nil {
		return nil, fmt.Errorf("failed performing ECDH key exchange: %w", err)
	}

	// 3. Sign the random token data so that the server can confirm the request
	// comes from a trusted client. This avoids replay attacks if the token is
	// intercepted in transit.
	privSignKey := ed25519.NewKeyFromSeed(sharedKey)
	tokenSig := ed25519.Sign(privSignKey, tokenData)
	tokenConcat := slices.Concat(tokenSig, tokenData)

	// 4. Send a join request to the remote node, providing the random token and
	// the local X25519 public key. If the token is valid and not expired, the
	// remote node will generate a TLS client certificate and private key,
	// encrypt them with the shared key, and send them in the response, along
	// with the server (CA) cert.
	c := client.New(address, nil)
	joinRespEnc, err := c.RemoteJoin(ctx, base58.Encode(tokenConcat), base58.Encode(pubKeyData))
	if err != nil {
		return nil, err
	}

	// 5. Decrypt the response payload with the shared key.
	var sharedKeyArr [32]byte
	copy(sharedKeyArr[:], sharedKey)
	joinRespJSON, err := crypto.DecryptSymInMemory(joinRespEnc, &sharedKeyArr)
	if err != nil {
		return nil, fmt.Errorf("failed decrypting join response payload: %w", err)
	}

	joinResp := &types.RemoteJoinResponsePayload{}
	err = json.Unmarshal(joinRespJSON, joinResp)
	if err != nil {
		return nil, fmt.Errorf("failed unmarshalling response body: %w", err)
	}

	return joinResp, nil
}

func decodeToken(token string) ([]byte, []byte, error) {
	tokenDec, err := base58.Decode(token)
	if err != nil {
		return nil, nil, fmt.Errorf("failed decoding token: %w", err)
	}
	if len(tokenDec) != 64 {
		return nil, nil, ErrInvalidToken
	}

	return tokenDec[:32], tokenDec[32:], nil
}
