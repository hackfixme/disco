package client

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"time"

	"go.hackfix.me/disco/web/server/types"
)

type Client struct {
	*http.Client
	address string
}

func New(address string) *Client {
	return &Client{
		Client: &http.Client{
			Timeout: 10 * time.Second,
			Transport: &http.Transport{
				DisableCompression: false,
			},
		},
		address: address,
	}
}

// Join sends a request to the remote node to authenticate the local node as a
// client, and allow remote access to store data or admin functionality,
// depending on the permissions granted to the user. The token is generated by
// the server, and is sent in the Authorization header. The pubKey is the
// client's X25519 public key, and is sent in the request body.
// If the token is valid and not expired, the server will generate a TLS client
// certificate, encrypt it with the X25519 shared key, and send it in the
// response body. This method returns the encrypted TLS client certificate.
func (c *Client) Join(ctx context.Context, token, pubKey string) (tlsClientCertEnc string, err error) {
	url := &url.URL{Scheme: "http", Host: c.address, Path: "/api/v1/join"}

	reqCtx, cancelReqCtx := context.WithCancel(ctx)
	defer cancelReqCtx()

	req, err := http.NewRequestWithContext(
		reqCtx, "POST", url.String(), bytes.NewBufferString(pubKey))
	if err != nil {
		return "", fmt.Errorf("failed creating request: %w", err)
	}

	req.Header.Set("Authorization", token)

	resp, err := c.Do(req)
	if err != nil {
		return "", fmt.Errorf("failed sending request: %w", err)
	}
	defer resp.Body.Close()

	joinRespBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", fmt.Errorf("failed reading response body: %w", err)
	}

	joinResp := types.RemoteJoinResponse{}
	err = json.Unmarshal(joinRespBody, &joinResp)
	if err != nil {
		return "", fmt.Errorf("failed unmarshalling response body: %w", err)
	}

	return joinResp.TLSClientCertEnc, nil
}
